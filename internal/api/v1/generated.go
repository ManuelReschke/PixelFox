// Package apiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package apiv1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gofiber/fiber/v2"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes      = "ApiKeyAuth.Scopes"
	BearerAuthScopes      = "BearerAuth.Scopes"
	UploadTokenAuthScopes = "UploadTokenAuth.Scopes"
)

// Error defines model for Error.
type Error struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error type identifier
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// Pong defines model for Pong.
type Pong struct {
	// Ping Simple response confirming API availability
	Ping string `json:"ping"`
}

// StorageUploadResponse defines model for StorageUploadResponse.
type StorageUploadResponse struct {
	Duplicate *bool   `json:"duplicate,omitempty"`
	ImageUuid *string `json:"image_uuid,omitempty"`
	ViewUrl   *string `json:"view_url,omitempty"`
}

// UploadSessionRequest defines model for UploadSessionRequest.
type UploadSessionRequest struct {
	// FileSize Größe der Datei in Bytes.
	FileSize int64 `json:"file_size"`
}

// UploadSessionResponse defines model for UploadSessionResponse.
type UploadSessionResponse struct {
	// ExpiresAt Ablaufzeit als Unix-Timestamp (Sekunden).
	ExpiresAt int64 `json:"expires_at"`

	// MaxBytes Maximale Dateigröße in Bytes, die mit diesem Token akzeptiert wird.
	MaxBytes int64 `json:"max_bytes"`

	// PoolId Interne ID des Storage-Pools.
	PoolId int64 `json:"pool_id"`

	// Token Zeitlich begrenzter Upload-Token (Bearer Token).
	Token string `json:"token"`

	// UploadUrl Vollständige URL zum Storage-Endpunkt.
	UploadUrl string `json:"upload_url"`
}

// UserAccount defines model for UserAccount.
type UserAccount struct {
	// ApiKeyLastUsedAt Letzte Verwendung des aktuellen API-Schlüssels
	ApiKeyLastUsedAt *time.Time `json:"api_key_last_used_at"`

	// CreatedAt Registrierungszeitpunkt
	CreatedAt time.Time `json:"created_at"`

	// Email Verknüpfte E-Mail-Adresse
	Email openapi_types.Email `json:"email"`

	// Id Benutzer-ID
	Id int64 `json:"id"`

	// IsAdmin Kennzeichnet Administratoren
	IsAdmin bool `json:"is_admin"`

	// LastLoginAt Zeitpunkt der letzten Anmeldung (falls vorhanden)
	LastLoginAt *time.Time        `json:"last_login_at"`
	Limits      UserAccountLimits `json:"limits"`

	// Plan Aktueller Paketplan
	Plan        string                 `json:"plan"`
	Preferences UserAccountPreferences `json:"preferences"`
	Stats       UserAccountStats       `json:"stats"`

	// Status Kontostatus
	Status string `json:"status"`

	// Username Anzeigename des Benutzers
	Username string `json:"username"`
}

// UserAccountLimits defines model for UserAccountLimits.
type UserAccountLimits struct {
	// AllowedThumbnailFormats Verfügbare Thumbnail-Formate
	AllowedThumbnailFormats []string `json:"allowed_thumbnail_formats"`

	// CanMultiUpload Darf Mehrfach-Uploads durchführen
	CanMultiUpload bool `json:"can_multi_upload"`

	// DirectUploadEnabled Globale Einstellung für Direkt-Uploads
	DirectUploadEnabled bool `json:"direct_upload_enabled"`

	// ImageUploadEnabled Globale Einstellung für Bild-Uploads
	ImageUploadEnabled bool `json:"image_upload_enabled"`

	// MaxUploadBytes Maximale Uploadgröße pro Datei (in Bytes)
	MaxUploadBytes int64 `json:"max_upload_bytes"`

	// StorageQuotaBytes Gesamtverfügbarer Speicher (null bei unbegrenzt)
	StorageQuotaBytes *int64 `json:"storage_quota_bytes"`
}

// UserAccountPreferences defines model for UserAccountPreferences.
type UserAccountPreferences struct {
	// ThumbnailAvif Bevorzugt AVIF-Thumbnails
	ThumbnailAvif bool `json:"thumbnail_avif"`

	// ThumbnailOriginal Bevorzugt Original-Thumbnails
	ThumbnailOriginal bool `json:"thumbnail_original"`

	// ThumbnailWebp Bevorzugt WebP-Thumbnails
	ThumbnailWebp bool `json:"thumbnail_webp"`
}

// UserAccountStats defines model for UserAccountStats.
type UserAccountStats struct {
	Albums struct {
		// Count Anzahl erstellter Alben
		Count int64 `json:"count"`
	} `json:"albums"`
	Images struct {
		// Count Anzahl gespeicherter Bilder
		Count int64 `json:"count"`

		// StorageRemainingBytes Verbleibender Speicherplatz (null bei unbegrenzt)
		StorageRemainingBytes *int64 `json:"storage_remaining_bytes"`

		// StorageUsedBytes Belegter Speicher in Bytes
		StorageUsedBytes int64 `json:"storage_used_bytes"`
	} `json:"images"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalError defines model for InternalError.
type InternalError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// PayloadTooLarge defines model for PayloadTooLarge.
type PayloadTooLarge = Error

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = Error

// PostDirectUploadMultipartBody defines parameters for PostDirectUpload.
type PostDirectUploadMultipartBody struct {
	File openapi_types.File `json:"file"`

	// Token Alternative to Authorization header: pass upload token as multipart field
	Token *string `json:"token,omitempty"`
}

// PostDirectUploadMultipartRequestBody defines body for PostDirectUpload for multipart/form-data ContentType.
type PostDirectUploadMultipartRequestBody PostDirectUploadMultipartBody

// PostUserUploadSessionJSONRequestBody defines body for PostUserUploadSession for application/json ContentType.
type PostUserUploadSessionJSONRequestBody = UploadSessionRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get processing status
	// (GET /image/status/{uuid})
	GetImageStatus(c *fiber.Ctx, uuid string) error
	// Health check endpoint
	// (GET /ping)
	GetPing(c *fiber.Ctx) error
	// Direct storage upload
	// (POST /upload)
	PostDirectUpload(c *fiber.Ctx) error
	// Issue direct upload session
	// (POST /upload/sessions)
	PostUserUploadSession(c *fiber.Ctx) error
	// Get authenticated user profile
	// (GET /user/profile)
	GetUserProfile(c *fiber.Ctx) error
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

type MiddlewareFunc fiber.Handler

// GetImageStatus operation middleware
func (siw *ServerInterfaceWrapper) GetImageStatus(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid string

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", c.Params("uuid"), &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter uuid: %w", err).Error())
	}

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetImageStatus(c, uuid)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetPing(c)
}

// PostDirectUpload operation middleware
func (siw *ServerInterfaceWrapper) PostDirectUpload(c *fiber.Ctx) error {

	c.Context().SetUserValue(UploadTokenAuthScopes, []string{})

	return siw.Handler.PostDirectUpload(c)
}

// PostUserUploadSession operation middleware
func (siw *ServerInterfaceWrapper) PostUserUploadSession(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	return siw.Handler.PostUserUploadSession(c)
}

// GetUserProfile operation middleware
func (siw *ServerInterfaceWrapper) GetUserProfile(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	return siw.Handler.GetUserProfile(c)
}

// FiberServerOptions provides options for the Fiber server.
type FiberServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router fiber.Router, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, FiberServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router fiber.Router, si ServerInterface, options FiberServerOptions) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	for _, m := range options.Middlewares {
		router.Use(fiber.Handler(m))
	}

	router.Get(options.BaseURL+"/image/status/:uuid", wrapper.GetImageStatus)

	router.Get(options.BaseURL+"/ping", wrapper.GetPing)

	router.Post(options.BaseURL+"/upload", wrapper.PostDirectUpload)

	router.Post(options.BaseURL+"/upload/sessions", wrapper.PostUserUploadSession)

	router.Get(options.BaseURL+"/user/profile", wrapper.GetUserProfile)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
