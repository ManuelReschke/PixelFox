// Package apiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package apiv1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gofiber/fiber/v2"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes      = "ApiKeyAuth.Scopes"
	BearerAuthScopes      = "BearerAuth.Scopes"
	UploadTokenAuthScopes = "UploadTokenAuth.Scopes"
)

// Defines values for ImageResourceAvailableVariants.
const (
	ImageResourceAvailableVariantsAvif     ImageResourceAvailableVariants = "avif"
	ImageResourceAvailableVariantsOriginal ImageResourceAvailableVariants = "original"
	ImageResourceAvailableVariantsWebp     ImageResourceAvailableVariants = "webp"
)

// Defines values for StorageUploadResponseAvailableVariants.
const (
	StorageUploadResponseAvailableVariantsAvif     StorageUploadResponseAvailableVariants = "avif"
	StorageUploadResponseAvailableVariantsOriginal StorageUploadResponseAvailableVariants = "original"
	StorageUploadResponseAvailableVariantsWebp     StorageUploadResponseAvailableVariants = "webp"
)

// Error defines model for Error.
type Error struct {
	// Details Additional error details
	Details *string `json:"details,omitempty"`

	// Error Error type identifier
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// FormatVariants defines model for FormatVariants.
type FormatVariants struct {
	Medium   *VariantSize `json:"medium,omitempty"`
	Original *VariantSize `json:"original,omitempty"`
	Small    *VariantSize `json:"small,omitempty"`
}

// ImageResource defines model for ImageResource.
type ImageResource struct {
	// AvailableVariants List of available variant-families for this image
	AvailableVariants *[]ImageResourceAvailableVariants `json:"available_variants,omitempty"`
	ImageUuid         string                            `json:"image_uuid"`

	// Url Direct URL to the original image file
	Url *string `json:"url,omitempty"`

	// Variants URLs of available variants grouped by family
	Variants *struct {
		Avif     *FormatVariants `json:"avif,omitempty"`
		Original *FormatVariants `json:"original,omitempty"`
		Webp     *FormatVariants `json:"webp,omitempty"`
	} `json:"variants,omitempty"`

	// ViewUrl Share page URL (HTML view)
	ViewUrl *string `json:"view_url,omitempty"`
}

// ImageResourceAvailableVariants defines model for ImageResource.AvailableVariants.
type ImageResourceAvailableVariants string

// Pong defines model for Pong.
type Pong struct {
	// Ping Simple response confirming API availability
	Ping string `json:"ping"`
}

// StorageUploadResponse defines model for StorageUploadResponse.
type StorageUploadResponse struct {
	// AvailableVariants List of available variant-families for this image
	AvailableVariants *[]StorageUploadResponseAvailableVariants `json:"available_variants,omitempty"`

	// Duplicate Indicates the uploaded file already exists for this user
	Duplicate *bool `json:"duplicate,omitempty"`

	// ImageUuid UUID of the uploaded image
	ImageUuid *string `json:"image_uuid,omitempty"`

	// Url Direct URL to the original image file
	Url *string `json:"url,omitempty"`

	// Variants URLs of available variants grouped by family
	Variants *struct {
		Avif     *FormatVariants `json:"avif,omitempty"`
		Original *FormatVariants `json:"original,omitempty"`
		Webp     *FormatVariants `json:"webp,omitempty"`
	} `json:"variants,omitempty"`

	// ViewUrl Share page URL (HTML view)
	ViewUrl *string `json:"view_url,omitempty"`
}

// StorageUploadResponseAvailableVariants defines model for StorageUploadResponse.AvailableVariants.
type StorageUploadResponseAvailableVariants string

// UploadSessionRequest defines model for UploadSessionRequest.
type UploadSessionRequest struct {
	// FileSize Größe der Datei in Bytes.
	FileSize int64 `json:"file_size"`
}

// UploadSessionResponse defines model for UploadSessionResponse.
type UploadSessionResponse struct {
	// ExpiresAt Ablaufzeit als Unix-Timestamp (Sekunden).
	ExpiresAt int64 `json:"expires_at"`

	// MaxBytes Maximale Dateigröße in Bytes, die mit diesem Token akzeptiert wird.
	MaxBytes int64 `json:"max_bytes"`

	// PoolId Interne ID des Storage-Pools.
	PoolId int64 `json:"pool_id"`

	// Token Zeitlich begrenzter Upload-Token (Bearer Token).
	Token string `json:"token"`

	// UploadUrl Vollständige URL zum Storage-Endpunkt.
	UploadUrl string `json:"upload_url"`
}

// UserAccount defines model for UserAccount.
type UserAccount struct {
	// ApiKeyLastUsedAt Letzte Verwendung des aktuellen API-Schlüssels
	ApiKeyLastUsedAt *time.Time `json:"api_key_last_used_at"`

	// CreatedAt Registrierungszeitpunkt
	CreatedAt time.Time `json:"created_at"`

	// Email Verknüpfte E-Mail-Adresse
	Email openapi_types.Email `json:"email"`

	// Id Benutzer-ID
	Id int64 `json:"id"`

	// LastLoginAt Zeitpunkt der letzten Anmeldung (falls vorhanden)
	LastLoginAt *time.Time        `json:"last_login_at"`
	Limits      UserAccountLimits `json:"limits"`

	// Plan Aktueller Paketplan
	Plan        string                 `json:"plan"`
	Preferences UserAccountPreferences `json:"preferences"`
	Stats       UserAccountStats       `json:"stats"`

	// Status Kontostatus
	Status string `json:"status"`

	// Username Anzeigename des Benutzers
	Username string `json:"username"`
}

// UserAccountLimits defines model for UserAccountLimits.
type UserAccountLimits struct {
	// AllowedThumbnailFormats Verfügbare Thumbnail-Formate
	AllowedThumbnailFormats []string `json:"allowed_thumbnail_formats"`

	// CanMultiUpload Darf Mehrfach-Uploads durchführen
	CanMultiUpload bool `json:"can_multi_upload"`

	// DirectUploadEnabled Globale Einstellung für Direkt-Uploads
	DirectUploadEnabled bool `json:"direct_upload_enabled"`

	// ImageUploadEnabled Globale Einstellung für Bild-Uploads
	ImageUploadEnabled bool `json:"image_upload_enabled"`

	// MaxUploadBytes Maximale Uploadgröße pro Datei (in Bytes)
	MaxUploadBytes int64 `json:"max_upload_bytes"`

	// StorageQuotaBytes Gesamtverfügbarer Speicher (null bei unbegrenzt)
	StorageQuotaBytes *int64 `json:"storage_quota_bytes"`
}

// UserAccountPreferences defines model for UserAccountPreferences.
type UserAccountPreferences struct {
	// ThumbnailAvif Bevorzugt AVIF-Thumbnails
	ThumbnailAvif bool `json:"thumbnail_avif"`

	// ThumbnailOriginal Bevorzugt Original-Thumbnails
	ThumbnailOriginal bool `json:"thumbnail_original"`

	// ThumbnailWebp Bevorzugt WebP-Thumbnails
	ThumbnailWebp bool `json:"thumbnail_webp"`
}

// UserAccountStats defines model for UserAccountStats.
type UserAccountStats struct {
	Albums struct {
		// Count Anzahl erstellter Alben
		Count int64 `json:"count"`
	} `json:"albums"`
	Images struct {
		// Count Anzahl gespeicherter Bilder
		Count int64 `json:"count"`

		// StorageRemainingBytes Verbleibender Speicherplatz (null bei unbegrenzt)
		StorageRemainingBytes *int64 `json:"storage_remaining_bytes"`

		// StorageUsedBytes Belegter Speicher in Bytes
		StorageUsedBytes int64 `json:"storage_used_bytes"`
	} `json:"images"`
}

// VariantSize defines model for VariantSize.
type VariantSize struct {
	// Animated Whether this asset is animated (e.g., GIF/WebP)
	Animated *bool `json:"animated,omitempty"`

	// Bytes File size in bytes if known
	Bytes *int64 `json:"bytes,omitempty"`

	// Height Pixel height if known
	Height *int `json:"height,omitempty"`

	// MimeType MIME type of this asset
	MimeType *string `json:"mime_type,omitempty"`
	Url      string  `json:"url"`

	// Width Pixel width if known
	Width *int `json:"width,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalError defines model for InternalError.
type InternalError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// PayloadTooLarge defines model for PayloadTooLarge.
type PayloadTooLarge = Error

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = Error

// PostDirectUploadMultipartBody defines parameters for PostDirectUpload.
type PostDirectUploadMultipartBody struct {
	File openapi_types.File `json:"file"`

	// Token Alternative to Authorization header: pass upload token as multipart field
	Token *string `json:"token,omitempty"`
}

// PostDirectUploadMultipartRequestBody defines body for PostDirectUpload for multipart/form-data ContentType.
type PostDirectUploadMultipartRequestBody PostDirectUploadMultipartBody

// PostUserUploadSessionJSONRequestBody defines body for PostUserUploadSession for application/json ContentType.
type PostUserUploadSessionJSONRequestBody = UploadSessionRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get image resource
	// (GET /images/{uuid})
	GetImage(c *fiber.Ctx, uuid string) error
	// Get processing status
	// (GET /images/{uuid}/status)
	GetImageStatus(c *fiber.Ctx, uuid string) error
	// Health check endpoint
	// (GET /ping)
	GetPing(c *fiber.Ctx) error
	// Direct storage upload
	// (POST /upload)
	PostDirectUpload(c *fiber.Ctx) error
	// Issue direct upload session
	// (POST /upload/sessions)
	PostUserUploadSession(c *fiber.Ctx) error
	// Get authenticated user profile
	// (GET /user/profile)
	GetUserProfile(c *fiber.Ctx) error
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

type MiddlewareFunc fiber.Handler

// GetImage operation middleware
func (siw *ServerInterfaceWrapper) GetImage(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid string

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", c.Params("uuid"), &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter uuid: %w", err).Error())
	}

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	return siw.Handler.GetImage(c, uuid)
}

// GetImageStatus operation middleware
func (siw *ServerInterfaceWrapper) GetImageStatus(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid string

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", c.Params("uuid"), &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter uuid: %w", err).Error())
	}

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetImageStatus(c, uuid)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetPing(c)
}

// PostDirectUpload operation middleware
func (siw *ServerInterfaceWrapper) PostDirectUpload(c *fiber.Ctx) error {

	c.Context().SetUserValue(UploadTokenAuthScopes, []string{})

	return siw.Handler.PostDirectUpload(c)
}

// PostUserUploadSession operation middleware
func (siw *ServerInterfaceWrapper) PostUserUploadSession(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	return siw.Handler.PostUserUploadSession(c)
}

// GetUserProfile operation middleware
func (siw *ServerInterfaceWrapper) GetUserProfile(c *fiber.Ctx) error {

	c.Context().SetUserValue(ApiKeyAuthScopes, []string{})

	return siw.Handler.GetUserProfile(c)
}

// FiberServerOptions provides options for the Fiber server.
type FiberServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router fiber.Router, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, FiberServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router fiber.Router, si ServerInterface, options FiberServerOptions) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	for _, m := range options.Middlewares {
		router.Use(fiber.Handler(m))
	}

	router.Get(options.BaseURL+"/images/:uuid", wrapper.GetImage)

	router.Get(options.BaseURL+"/images/:uuid/status", wrapper.GetImageStatus)

	router.Get(options.BaseURL+"/ping", wrapper.GetPing)

	router.Post(options.BaseURL+"/upload", wrapper.PostDirectUpload)

	router.Post(options.BaseURL+"/upload/sessions", wrapper.PostUserUploadSession)

	router.Get(options.BaseURL+"/user/profile", wrapper.GetUserProfile)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
